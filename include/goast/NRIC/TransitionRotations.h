// This file is part of GOAST, a C++ library for variational methods in Geometry Processing
//
// Copyright (C) 2020 Behrend Heeren & Josua Sassen, University of Bonn <goast@ins.uni-bonn.de>
//
// This Source Code Form is subject to the terms of the Mozilla
// Public License v. 2.0. If a copy of the MPL was not distributed
// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
/**
 * \file
 * \brief Implementation of intrinsic transition rotations
 * \author Sassen
 *
 * Based on Yue Wang, B. Liu, and Y. Tong. Linear surface reconstruction from discrete fundamental forms on triangle
 * meshes. Comput. Graph. Forum, 31:2277–2287, 2012.
 *
 * \note This directly relies on the Axis-Angle and Quaternion implementations from Eigen
 * \note Below you will find some code generated by Mathematica, which will be quite ugly.. Just a heads up
 * \todo Remove Mathematica-generated code
 */

#ifndef NRIC_TRANSITIONROTATIONS_H
#define NRIC_TRANSITIONROTATIONS_H

#include <goast/Core/Auxiliary.h>
#include <goast/Core/Topology.h>

#include "TrigonometryOperators.h"

#include <algorithm>
#include <array>

#include <Eigen/Geometry>
#include <unsupported/Eigen/CXX11/Tensor>

/**
 * \brief Operator determining transition rotations for each edge
 * \author Sassen
 * \tparam ConfiguratorType Container with data types
 *
 * Computes the transition rotations for each interior edge as introduced in Yue Wang, B. Liu, and Y. Tong.
 * Linear surface reconstruction from discrete fundamental forms on triangle meshes. Comput. Graph. Forum,
 * 31:2277–2287, 2012. They describe how the orientation of triangles (considered in terms of the directions
 * of its normal and first edge) adjacent to edges are related to each other.
 *
 * \todo Pre-compute needed topological information
 */
template<typename ConfiguratorType>
class TransitionRotationsOp {
  // : public BaseOp<typename ConfiguratorType::VectorType, std::vector<Eigen::Matrix<typename ConfiguratorType::RealType, 3, 3>>>
protected:
  typedef typename ConfiguratorType::RealType RealType;

  typedef typename ConfiguratorType::VectorType VectorType;
  typedef typename ConfiguratorType::VecType VecType;
  typedef typename ConfiguratorType::MatType MatType;
  typedef typename ConfiguratorType::RotationType RotationType;
  typedef typename ConfiguratorType::AngleAxisType AngleAxisType;
  const Eigen::Matrix<RealType, 3, 1> UnitZ = Eigen::Matrix<RealType, 3, 1>::UnitZ();
  const Eigen::Matrix<RealType, 3, 1> UnitX = Eigen::Matrix<RealType, 3, 1>::UnitX();

  const MeshTopologySaver &_topology;
  const int _numEdges;
  std::vector<std::pair<long, long>> localIndices;

public:
  /**
   * \brief Initialize operator
   * \param topology class containing information on the topology (i.e. connectivity) of the mesh.
   */
  explicit TransitionRotationsOp( const MeshTopologySaver &topology ) : _topology( topology ),
                                                                        _numEdges( topology.getNumEdges()) {
    // Pre-compute the local indices for each edge, i.e. which index they have in the adjacent triangles
    localIndices.resize( _numEdges, std::make_pair<long, long>( -1, -1 ));
    for ( int edgeIdx = 0; edgeIdx < _topology.getNumEdges(); edgeIdx++ ) {
      // Determine triangles
      int f1 = _topology.getAdjacentTriangleOfEdge( edgeIdx, 0 );
      int f2 = _topology.getAdjacentTriangleOfEdge( edgeIdx, 1 );

      // Ignore boundary edges
      if ( f1 == -1 || f2 == -1 )
        continue;

      // Determine edges
      std::array<int, 3> e1 = { _topology.getEdgeOfTriangle( f1, 0 ),
                                _topology.getEdgeOfTriangle( f1, 1 ),
                                _topology.getEdgeOfTriangle( f1, 2 ) };

      std::array<int, 3> e2 = { _topology.getEdgeOfTriangle( f2, 0 ),
                                _topology.getEdgeOfTriangle( f2, 1 ),
                                _topology.getEdgeOfTriangle( f2, 2 ) };

      // Determine which local indices the common edge has and the local indices of the angle between the two
      long eIdx_f1 = std::distance( e1.begin(), std::find( e1.begin(), e1.end(), edgeIdx ));
      long eIdx_f2 = std::distance( e2.begin(), std::find( e2.begin(), e2.end(), edgeIdx ));

      localIndices[edgeIdx] = std::make_pair( eIdx_f1, eIdx_f2 );
    }
  }

  /**
   * \brief Evaluate operator
   * \param Arg Edges lengths and dihedral angles as vector of size \f$2*|E|\f$
   * \param Dest Transition rotation for each edge given as vector of quaternions
   */
  void apply( const VectorType &Arg, std::vector<RotationType> &Dest ) const {
    if ( Arg.size() < _topology.getNumEdges())
      throw std::length_error( "TriangleAreaOp::apply(): Arg too small!" );

    if ( Dest.size() != _topology.getNumEdges())
      Dest.resize( _topology.getNumEdges());

    VectorType interiorAngles;
    InteriorAngleOp<ConfiguratorType>( _topology ).apply( Arg, interiorAngles );

    apply( Arg, interiorAngles, Dest );
  }

  /**
   * \brief Evaluate operator with given interior angles
   * \param Arg Edges lengths and dihedral angles as vector of size \f$2*|E|\f$
   * \param interiorAngles Precomputed interior angles of the triangles
   * \param Dest Transition rotation for each edge given as vector of quaternions
   */
  void apply( const VectorType &Arg, const VectorType &interiorAngles, std::vector<RotationType> &Dest ) const {
    if ( Arg.size() < _topology.getNumEdges())
      throw std::length_error( "TriangleAreaOp::apply(): Arg too small!" );

    Dest.resize( _topology.getNumEdges());

#ifdef GOAST_WITH_OPENMP
#pragma omp parallel for schedule(static)
#endif
    for ( int edgeIdx = 0; edgeIdx < _topology.getNumEdges(); edgeIdx++ ) {
      // Determine triangles
      int f1 = _topology.getAdjacentTriangleOfEdge( edgeIdx, 0 );
      int f2 = _topology.getAdjacentTriangleOfEdge( edgeIdx, 1 );

      if ( f1 == -1 || f2 == -1 )
        continue;

      // Determine which local indices the common edge has and the local indices of the angle between the two
      long eIdx_f1 = localIndices[edgeIdx].first;
      long eIdx_f2 = localIndices[edgeIdx].second;

      // Interior rotation angles
      RealType gamma1 = ( eIdx_f1 == 0 ) ? 0 :
                        ( eIdx_f1 == 1 ) ? M_PI + interiorAngles[3 * f1 + 2] : M_PI - interiorAngles[3 * f1 + 1];
      RealType gamma2 = ( eIdx_f2 == 0 ) ? M_PI :
                        ( eIdx_f2 == 1 ) ? +interiorAngles[3 * f2 + 2] : -interiorAngles[3 * f2 + 1];

      // Rotation
      Dest[edgeIdx] = RotationType( AngleAxisType( gamma1, UnitZ ) *
                                    AngleAxisType( Arg[_numEdges + edgeIdx], UnitX ) *
                                    AngleAxisType( -gamma2, UnitZ ));
    }
  }

  /**
   * \brief Evaluate operator with given interior angles for a subset of edges in the mesh
   * \param Arg Edges lengths and dihedral angles as vector of size \f$2*|E|\f$
   * \param interiorAngles Precomputed interior angles of the triangles
   * \param Dest Transition rotation for each edge given as vector of quaternions
   * \param edges Vector with indices of edges for which the rotations should be computed
   */
  void apply( const VectorType &Arg, const VectorType &interiorAngles, std::vector<RotationType> &Dest,
              const std::vector<int> &edges ) const {
    if ( Arg.size() < _topology.getNumEdges())
      throw std::length_error( "TriangleAreaOp::apply(): Arg too small!" );

    Dest.resize( _topology.getNumEdges());
#ifdef GOAST_WITH_OPENMP
#pragma omp parallel for
#endif
    for ( int i = 0; i < edges.size(); i++ ) {
      const int &edgeIdx = edges[i];
      // Determine triangles
      int f1 = _topology.getAdjacentTriangleOfEdge( edgeIdx, 0 );
      int f2 = _topology.getAdjacentTriangleOfEdge( edgeIdx, 1 );

      if ( f1 == -1 || f2 == -1 )
        continue;

      // Determine which local indices the common edge has and the local indices of the angle between the two
      long eIdx_f1 = localIndices[edgeIdx].first;
      long eIdx_f2 = localIndices[edgeIdx].second;

      // Interior rotation angles
      RealType gamma1 = ( eIdx_f1 == 0 ) ? 0 :
                        ( eIdx_f1 == 1 ) ? M_PI + interiorAngles[3 * f1 + 2] : M_PI - interiorAngles[3 * f1 + 1];
      RealType gamma2 = ( eIdx_f2 == 0 ) ? M_PI :
                        ( eIdx_f2 == 1 ) ? +interiorAngles[3 * f2 + 2] : -interiorAngles[3 * f2 + 1];

      // Rotation
      Dest[edgeIdx] = AngleAxisType( gamma1, UnitZ ) *
                      AngleAxisType( Arg[_numEdges + edgeIdx], UnitX ) *
                      AngleAxisType( -gamma2, UnitZ );
    }
  }

  void applyAdd( const VectorType &Arg, std::vector<RotationType> &Dest ) const {
    throw std::logic_error( "Not implemented" );
  }
};

/**
 * \brief Compute local transition rotation from edge lengths and dihedral angle
 * \author Sassen
 * \tparam ConfiguratorType Container with data types
 *
 * This computes the rotation \f$R(\theta,a,b,c) = R_x(\theta) R_z(\gamma(a,b,c))\f$, where \gamma(a,b,c) is the
 * interior angle determined via law of cosines
 */
template<typename ConfiguratorType>
class LocalTransitionRotationOp {
protected:
  typedef typename ConfiguratorType::RealType RealType;

  typedef typename ConfiguratorType::VectorType VectorType;
  typedef typename ConfiguratorType::VecType VecType;
  typedef typename ConfiguratorType::MatType MatType;
  typedef typename ConfiguratorType::RotationType RotationType;
  typedef typename ConfiguratorType::AngleAxisType AngleAxisType;
  const Eigen::Matrix<RealType, 3, 1> UnitZ = Eigen::Matrix<RealType, 3, 1>::UnitZ();
  const Eigen::Matrix<RealType, 3, 1> UnitX = Eigen::Matrix<RealType, 3, 1>::UnitX();

public:
  explicit LocalTransitionRotationOp() = default;

  void apply( const RealType &theta, const RealType &a, const RealType &b, const RealType &c,
              RotationType &Dest ) const {
    RealType gamma = acos(( pow( a, 2 ) + pow( b, 2 ) - pow( c, 2 )) / ( 2 * a * b ));
    Dest = AngleAxisType( theta, UnitX ) * AngleAxisType( gamma, UnitZ );
  }

  RotationType operator()( const RealType &theta, const RealType &a, const RealType &b, const RealType &c ) {
    RealType gamma = acos(( pow( a, 2 ) + pow( b, 2 ) - pow( c, 2 )) / ( 2 * a * b ));
    return RotationType( AngleAxisType( theta, UnitX ) * AngleAxisType( gamma, UnitZ ));
  }

};

/**
 * \brief Compute derivative of simplified transition rotation w.r.t. edge lengths and dihedral angle
 * \author Sassen
 * \tparam ConfiguratorType Container with data types
 * \see SimplifiedLocalTransitionRotationsOp
 *
 * \note The C-code was generated by Mathematica, sorry.
 * \todo Clean this up and improve speed
 */
template<typename ConfiguratorType>
class LocalTransitionRotationGradient {
protected:
  typedef typename ConfiguratorType::RealType RealType;

  typedef typename ConfiguratorType::VectorType VectorType;
  typedef typename ConfiguratorType::VecType VecType;
  typedef typename ConfiguratorType::MatType MatType;
  typedef typename ConfiguratorType::RotationType RotationType;

  template<typename D, int R>
  using TensorType = Eigen::Tensor<D, R>;

public:
  explicit LocalTransitionRotationGradient() = default;

  void apply( const RealType &theta, const RealType &a, const RealType &b, const RealType &c,
              TensorType<RealType, 3> &Dest ) const {
    Dest.resize( 3, 3, 4 );
    Dest.setZero();

    // From here on: auto-generated code from Mathematica

    int I0_0 = 4;
    int I0_1 = 2;
    int I0_2 = 1;
    int I0_3 = 0;
    RealType R0_23 = -0.25;
    RealType R0_33 = 0.5;
    RealType R0_42 = -0.5;

    RealType R0_0;
    RealType R0_1;
    RealType R0_2;
    RealType R0_3;
    RealType R0_4;
    RealType R0_5;
    RealType R0_6;
    RealType R0_7;
    RealType R0_8;
    RealType R0_9;
    RealType R0_10;
    RealType R0_11;
    RealType R0_12;
    RealType R0_13;
    RealType R0_14;
    RealType R0_15;
    RealType R0_16;
    RealType R0_17;
    RealType R0_18;
    RealType R0_19;
    RealType R0_20;
    RealType R0_21;
    RealType R0_22;
    RealType R0_24;
    RealType R0_25;
    RealType R0_26;
    RealType R0_27;
    RealType R0_28;
    RealType R0_29;
    RealType R0_30;
    RealType R0_31;
    RealType R0_32;
    RealType R0_34;
    RealType R0_35;
    RealType R0_36;
    RealType R0_37;
    RealType R0_38;
    RealType R0_39;
    RealType R0_40;
    RealType R0_41;
    RealType R0_43;
    RealType R0_44;
    RealType R0_45;
    RealType R0_46;
    RealType R0_47;
    RealType R0_48;
    RealType R0_49;
    RealType R0_50;
    RealType R0_51;
    RealType R0_52;
    RealType R0_53;
    RealType R0_54;
    RealType R0_55;
    RealType R0_56;
    RealType R0_57;
    RealType R0_58;
    RealType R0_59;
    RealType R0_60;
    RealType R0_61;
    RealType R0_62;
    RealType R0_63;
    RealType R0_64;
    RealType R0_65;
    RealType R0_66;
    RealType R0_67;
    RealType R0_68;
    RealType R0_69;
    RealType R0_70;

    int err = 0;

    R0_0 = theta;
    R0_1 = a;
    R0_2 = b;
    R0_3 = c;

    R0_4 = R0_1 * R0_1;
    R0_5 = R0_2 * R0_2;
    R0_6 = R0_3 * R0_3;
    R0_7 = 1 / R0_1;
    R0_8 = 1 / R0_2;
    R0_9 = R0_1 * R0_1;
    R0_10 = 1 / R0_9;

    unsigned int S0 = I0_0;
    RealType S1 = R0_1;
    bool S2 = false;
    if ( S0 < 0 ) {
      S2 = true;
      S0 = -S0;
    }
    R0_9 = 1;
    while ( S0 ) {
      if ( S0 & 1 ) {
        R0_9 = S1 * R0_9;
      }
      S1 = S1 * S1;
      S0 = S0 >> 1;
    }
    if ( S2 ) {
      R0_9 = 1 / R0_9;
    }

    R0_11 = -R0_6;
    R0_12 = R0_5 + R0_11;
    R0_13 = R0_12 * R0_12;
    R0_14 = -R0_13;
    R0_15 = R0_2 * R0_2;
    R0_16 = 1 / R0_15;
    R0_15 = -R0_9;
    R0_17 = R0_5 + R0_6;
    R0_18 = ( RealType ) I0_1;
    R0_18 = R0_18 * R0_4 * R0_17;
    R0_19 = R0_15 + R0_14 + R0_18;

    R0_20 = 1 / sqrt( R0_19 );

    R0_21 = R0_4 + R0_5 + R0_11;
    R0_22 = R0_21 * R0_21;
    R0_24 = R0_23 * R0_10 * R0_16 * R0_22;
    R0_25 = ( RealType ) I0_2;
    R0_25 = R0_25 + R0_24;
    R0_26 = -R0_5;
    R0_27 = R0_4 + R0_26 + R0_6;
    R0_28 = cos( R0_0 );

    R0_29 = 1 / sqrt( R0_25 );

    R0_30 = sin( R0_0 );
    R0_31 = R0_4 + R0_26 + R0_11;
    R0_32 = sqrt( R0_25 );
    R0_34 = R0_33 * R0_10 * R0_8 * R0_27;
    R0_35 = -R0_4;
    R0_35 = R0_35 + R0_5 + R0_6;
    R0_36 = R0_33 * R0_7 * R0_16 * R0_35;
    R0_35 = R0_7 * R0_8 * R0_3;
    R0_37 = -R0_35;
    R0_35 = R0_9 + R0_14;
    R0_38 = R0_33 * R0_10 * R0_8 * R0_35 * R0_20;

    S0 = I0_0;
    S1 = R0_2;
    S2 = 0;
    if ( S0 < 0 ) {
      S2 = 1;
      S0 = -S0;
    }
    R0_35 = 1;
    while ( S0 ) {
      if ( S0 & 1 ) {
        R0_35 = S1 * R0_35;
      }
      S1 = S1 * S1;
      S0 = S0 >> 1;
    }
    if ( S2 ) {
      R0_35 = 1 / R0_35;
    }

    R0_39 = ( RealType ) I0_1;
    R0_39 = R0_39 * R0_4 * R0_6;

    S0 = I0_0;
    S1 = R0_3;
    S2 = 0;
    if ( S0 < 0 ) {
      S2 = 1;
      S0 = -S0;
    }
    R0_40 = 1;
    while ( S0 ) {
      if ( S0 & 1 ) {
        R0_40 = S1 * R0_40;
      }
      S1 = S1 * S1;
      S0 = S0 >> 1;
    }
    if ( S2 ) {
      R0_40 = 1 / R0_40;
    }

    R0_41 = -R0_40;
    R0_40 = R0_15 + R0_35 + R0_39 + R0_41;
    R0_35 = R0_33 * R0_7 * R0_16 * R0_40 * R0_20;
    R0_39 = R0_42 * R0_10 * R0_16 * R0_3 * R0_21 * R0_29;
    R0_41 = R0_32 * R0_30;
    R0_40 = -R0_41;
    R0_41 = R0_42 * R0_10 * R0_8 * R0_21 * R0_27 * R0_20 * R0_28;
    R0_43 = R0_33 * R0_7 * R0_16 * R0_31 * R0_21 * R0_20 * R0_28;
    R0_44 = R0_33 * R0_10 * R0_16 * R0_3 * R0_21 * R0_29 * R0_28;
    R0_45 = R0_42 * R0_7 * R0_8 * R0_21 * R0_30;
    R0_46 = R0_33 * R0_10 * R0_8 * R0_27 * R0_28;
    R0_47 = R0_42 * R0_7 * R0_16 * R0_31 * R0_28;
    R0_48 = R0_7 * R0_8 * R0_3 * R0_28;
    R0_49 = -R0_48;
    R0_48 = -R0_28;
    R0_50 = R0_32 * R0_28;
    R0_51 = R0_42 * R0_10 * R0_8 * R0_21 * R0_27 * R0_20 * R0_30;
    R0_52 = R0_33 * R0_7 * R0_16 * R0_31 * R0_21 * R0_20 * R0_30;
    R0_53 = R0_33 * R0_10 * R0_16 * R0_3 * R0_21 * R0_29 * R0_30;
    R0_54 = R0_33 * R0_7 * R0_8 * R0_21 * R0_28;
    R0_55 = R0_33 * R0_10 * R0_8 * R0_27 * R0_30;
    R0_56 = R0_42 * R0_7 * R0_16 * R0_31 * R0_30;
    R0_57 = R0_7 * R0_8 * R0_3 * R0_30;
    R0_58 = -R0_57;
    R0_57 = -R0_30;
    R0_59 = ( RealType ) I0_3;
    R0_60 = ( RealType ) I0_3;
    R0_61 = ( RealType ) I0_3;
    R0_62 = ( RealType ) I0_3;
    R0_63 = ( RealType ) I0_3;
    R0_64 = ( RealType ) I0_3;
    R0_65 = ( RealType ) I0_3;
    R0_66 = ( RealType ) I0_3;
    R0_67 = ( RealType ) I0_3;
    R0_68 = ( RealType ) I0_3;
    R0_69 = ( RealType ) I0_3;
    R0_70 = ( RealType ) I0_3;

    //(0,0,x)
    Dest( 0, 0, 0 ) = R0_59;
    Dest( 0, 0, 1 ) = R0_34;
    Dest( 0, 0, 2 ) = R0_36;
    Dest( 0, 0, 3 ) = R0_37;

    //(0,1,x)
    Dest( 0, 1, 0 ) = R0_60;
    Dest( 0, 1, 1 ) = R0_38;
    Dest( 0, 1, 2 ) = R0_35;
    Dest( 0, 1, 3 ) = R0_39;

    //(0,2,x)
    Dest( 0, 2, 0 ) = R0_61;
    Dest( 0, 2, 1 ) = R0_62;
    Dest( 0, 2, 2 ) = R0_63;
    Dest( 0, 2, 3 ) = R0_64;

    //(1,0,x)
    Dest( 1, 0, 0 ) = R0_40;
    Dest( 1, 0, 1 ) = R0_41;
    Dest( 1, 0, 2 ) = R0_43;
    Dest( 1, 0, 3 ) = R0_44;

    //(1,1,x)
    Dest( 1, 1, 0 ) = R0_45;
    Dest( 1, 1, 1 ) = R0_46;
    Dest( 1, 1, 2 ) = R0_47;
    Dest( 1, 1, 3 ) = R0_49;

    //(1,2,x)
    Dest( 1, 2, 0 ) = R0_48;
    Dest( 1, 2, 1 ) = R0_65;
    Dest( 1, 2, 2 ) = R0_66;
    Dest( 1, 2, 3 ) = R0_67;

    //(2,0,x)
    Dest( 2, 0, 0 ) = R0_50;
    Dest( 2, 0, 1 ) = R0_51;
    Dest( 2, 0, 2 ) = R0_52;
    Dest( 2, 0, 3 ) = R0_53;

    //(2,1,x)
    Dest( 2, 1, 0 ) = R0_54;
    Dest( 2, 1, 1 ) = R0_55;
    Dest( 2, 1, 2 ) = R0_56;
    Dest( 2, 1, 3 ) = R0_58;

    //(2,2,x)
    Dest( 2, 2, 0 ) = R0_57;
    Dest( 2, 2, 1 ) = R0_68;
    Dest( 2, 2, 2 ) = R0_69;
    Dest( 2, 2, 3 ) = R0_70;
  }

  void apply( const RealType &theta, const RealType &a, const RealType &b, const RealType &c,
              std::array<RotationType, 4> &Dest ) const {
//    Dest.resize( 3, 3, 4 );
//    Dest.setZero();

    // From here on: auto-generated code from Mathematica

    int I0_0 = 4;
    int I0_1 = 2;
    int I0_2 = 1;
    int I0_3 = 0;
    RealType R0_23 = -0.25;
    RealType R0_33 = 0.5;
    RealType R0_42 = -0.5;

    RealType R0_0;
    RealType R0_1;
    RealType R0_2;
    RealType R0_3;
    RealType R0_4;
    RealType R0_5;
    RealType R0_6;
    RealType R0_7;
    RealType R0_8;
    RealType R0_9;
    RealType R0_10;
    RealType R0_11;
    RealType R0_12;
    RealType R0_13;
    RealType R0_14;
    RealType R0_15;
    RealType R0_16;
    RealType R0_17;
    RealType R0_18;
    RealType R0_19;
    RealType R0_20;
    RealType R0_21;
    RealType R0_22;
    RealType R0_24;
    RealType R0_25;
    RealType R0_26;
    RealType R0_27;
    RealType R0_28;
    RealType R0_29;
    RealType R0_30;
    RealType R0_31;
    RealType R0_32;
    RealType R0_34;
    RealType R0_35;
    RealType R0_36;
    RealType R0_37;
    RealType R0_38;
    RealType R0_39;
    RealType R0_40;
    RealType R0_41;
    RealType R0_43;
    RealType R0_44;
    RealType R0_45;
    RealType R0_46;
    RealType R0_47;
    RealType R0_48;
    RealType R0_49;
    RealType R0_50;
    RealType R0_51;
    RealType R0_52;
    RealType R0_53;
    RealType R0_54;
    RealType R0_55;
    RealType R0_56;
    RealType R0_57;
    RealType R0_58;
    RealType R0_59;
    RealType R0_60;
    RealType R0_61;
    RealType R0_62;
    RealType R0_63;
    RealType R0_64;
    RealType R0_65;
    RealType R0_66;
    RealType R0_67;
    RealType R0_68;
    RealType R0_69;
    RealType R0_70;

    int err = 0;

    R0_0 = theta;
    R0_1 = a;
    R0_2 = b;
    R0_3 = c;

    R0_4 = R0_1 * R0_1;
    R0_5 = R0_2 * R0_2;
    R0_6 = R0_3 * R0_3;
    R0_7 = 1 / R0_1;
    R0_8 = 1 / R0_2;
    R0_9 = R0_1 * R0_1;
    R0_10 = 1 / R0_9;

    unsigned int S0 = I0_0;
    RealType S1 = R0_1;
    bool S2 = false;
    if ( S0 < 0 ) {
      S2 = true;
      S0 = -S0;
    }
    R0_9 = 1;
    while ( S0 ) {
      if ( S0 & 1 ) {
        R0_9 = S1 * R0_9;
      }
      S1 = S1 * S1;
      S0 = S0 >> 1;
    }
    if ( S2 ) {
      R0_9 = 1 / R0_9;
    }

    R0_11 = -R0_6;
    R0_12 = R0_5 + R0_11;
    R0_13 = R0_12 * R0_12;
    R0_14 = -R0_13;
    R0_15 = R0_2 * R0_2;
    R0_16 = 1 / R0_15;
    R0_15 = -R0_9;
    R0_17 = R0_5 + R0_6;
    R0_18 = ( RealType ) I0_1;
    R0_18 = R0_18 * R0_4 * R0_17;
    R0_19 = R0_15 + R0_14 + R0_18;

    R0_20 = 1 / sqrt( R0_19 );

    R0_21 = R0_4 + R0_5 + R0_11;
    R0_22 = R0_21 * R0_21;
    R0_24 = R0_23 * R0_10 * R0_16 * R0_22;
    R0_25 = ( RealType ) I0_2;
    R0_25 = R0_25 + R0_24;
    R0_26 = -R0_5;
    R0_27 = R0_4 + R0_26 + R0_6;
    R0_28 = cos( R0_0 );

    R0_29 = 1 / sqrt( R0_25 );

    R0_30 = sin( R0_0 );
    R0_31 = R0_4 + R0_26 + R0_11;
    R0_32 = sqrt( R0_25 );
    R0_34 = R0_33 * R0_10 * R0_8 * R0_27;
    R0_35 = -R0_4;
    R0_35 = R0_35 + R0_5 + R0_6;
    R0_36 = R0_33 * R0_7 * R0_16 * R0_35;
    R0_35 = R0_7 * R0_8 * R0_3;
    R0_37 = -R0_35;
    R0_35 = R0_9 + R0_14;
    R0_38 = R0_33 * R0_10 * R0_8 * R0_35 * R0_20;

    S0 = I0_0;
    S1 = R0_2;
    S2 = 0;
    if ( S0 < 0 ) {
      S2 = 1;
      S0 = -S0;
    }
    R0_35 = 1;
    while ( S0 ) {
      if ( S0 & 1 ) {
        R0_35 = S1 * R0_35;
      }
      S1 = S1 * S1;
      S0 = S0 >> 1;
    }
    if ( S2 ) {
      R0_35 = 1 / R0_35;
    }

    R0_39 = ( RealType ) I0_1;
    R0_39 = R0_39 * R0_4 * R0_6;

    S0 = I0_0;
    S1 = R0_3;
    S2 = 0;
    if ( S0 < 0 ) {
      S2 = 1;
      S0 = -S0;
    }
    R0_40 = 1;
    while ( S0 ) {
      if ( S0 & 1 ) {
        R0_40 = S1 * R0_40;
      }
      S1 = S1 * S1;
      S0 = S0 >> 1;
    }
    if ( S2 ) {
      R0_40 = 1 / R0_40;
    }

    R0_41 = -R0_40;
    R0_40 = R0_15 + R0_35 + R0_39 + R0_41;
    R0_35 = R0_33 * R0_7 * R0_16 * R0_40 * R0_20;
    R0_39 = R0_42 * R0_10 * R0_16 * R0_3 * R0_21 * R0_29;
    R0_41 = R0_32 * R0_30;
    R0_40 = -R0_41;
    R0_41 = R0_42 * R0_10 * R0_8 * R0_21 * R0_27 * R0_20 * R0_28;
    R0_43 = R0_33 * R0_7 * R0_16 * R0_31 * R0_21 * R0_20 * R0_28;
    R0_44 = R0_33 * R0_10 * R0_16 * R0_3 * R0_21 * R0_29 * R0_28;
    R0_45 = R0_42 * R0_7 * R0_8 * R0_21 * R0_30;
    R0_46 = R0_33 * R0_10 * R0_8 * R0_27 * R0_28;
    R0_47 = R0_42 * R0_7 * R0_16 * R0_31 * R0_28;
    R0_48 = R0_7 * R0_8 * R0_3 * R0_28;
    R0_49 = -R0_48;
    R0_48 = -R0_28;
    R0_50 = R0_32 * R0_28;
    R0_51 = R0_42 * R0_10 * R0_8 * R0_21 * R0_27 * R0_20 * R0_30;
    R0_52 = R0_33 * R0_7 * R0_16 * R0_31 * R0_21 * R0_20 * R0_30;
    R0_53 = R0_33 * R0_10 * R0_16 * R0_3 * R0_21 * R0_29 * R0_30;
    R0_54 = R0_33 * R0_7 * R0_8 * R0_21 * R0_28;
    R0_55 = R0_33 * R0_10 * R0_8 * R0_27 * R0_30;
    R0_56 = R0_42 * R0_7 * R0_16 * R0_31 * R0_30;
    R0_57 = R0_7 * R0_8 * R0_3 * R0_30;
    R0_58 = -R0_57;
    R0_57 = -R0_30;
    R0_59 = ( RealType ) I0_3;
    R0_60 = ( RealType ) I0_3;
    R0_61 = ( RealType ) I0_3;
    R0_62 = ( RealType ) I0_3;
    R0_63 = ( RealType ) I0_3;
    R0_64 = ( RealType ) I0_3;
    R0_65 = ( RealType ) I0_3;
    R0_66 = ( RealType ) I0_3;
    R0_67 = ( RealType ) I0_3;
    R0_68 = ( RealType ) I0_3;
    R0_69 = ( RealType ) I0_3;
    R0_70 = ( RealType ) I0_3;

    //(0,0,x)
    Dest[0]( 0, 0 ) = R0_59;
    Dest[1]( 0, 0 ) = R0_34;
    Dest[2]( 0, 0 ) = R0_36;
    Dest[3]( 0, 0 ) = R0_37;

    //(0,1,x)
    Dest[0]( 0, 1 ) = R0_60;
    Dest[1]( 0, 1 ) = R0_38;
    Dest[2]( 0, 1 ) = R0_35;
    Dest[3]( 0, 1 ) = R0_39;

    //(0,2,x)
    Dest[0]( 0, 2 ) = R0_61;
    Dest[1]( 0, 2 ) = R0_62;
    Dest[2]( 0, 2 ) = R0_63;
    Dest[3]( 0, 2 ) = R0_64;

    //(1,0,x)
    Dest[0]( 1, 0 ) = R0_40;
    Dest[1]( 1, 0 ) = R0_41;
    Dest[2]( 1, 0 ) = R0_43;
    Dest[3]( 1, 0 ) = R0_44;

    //(1,1,x)
    Dest[0]( 1, 1 ) = R0_45;
    Dest[1]( 1, 1 ) = R0_46;
    Dest[2]( 1, 1 ) = R0_47;
    Dest[3]( 1, 1 ) = R0_49;

    //(1,2,x)
    Dest[0]( 1, 2 ) = R0_48;
    Dest[1]( 1, 2 ) = R0_65;
    Dest[2]( 1, 2 ) = R0_66;
    Dest[3]( 1, 2 ) = R0_67;

    //(2,0,x)
    Dest[0]( 2, 0 ) = R0_50;
    Dest[1]( 2, 0 ) = R0_51;
    Dest[2]( 2, 0 ) = R0_52;
    Dest[3]( 2, 0 ) = R0_53;

    //(2,1,x)
    Dest[0]( 2, 1 ) = R0_54;
    Dest[1]( 2, 1 ) = R0_55;
    Dest[2]( 2, 1 ) = R0_56;
    Dest[3]( 2, 1 ) = R0_58;

    //(2,2,x)
    Dest[0]( 2, 2 ) = R0_57;
    Dest[1]( 2, 2 ) = R0_68;
    Dest[2]( 2, 2 ) = R0_69;
    Dest[3]( 2, 2 ) = R0_70;
  }

  TensorType<RealType, 3> operator()( const RealType &theta, const RealType &a, const RealType &b, const RealType &c ) {
    TensorType<RealType, 3> Dest;
    apply( theta, a, b, c, Dest );
    return Dest;
  }

};

/**
 * \brief Compute Hessian of simplified transition rotation w.r.t. edge lengths and dihedral angle
 * \author Sassen
 * \tparam ConfiguratorType Container with data types
 * \see SimplifiedLocalTransitionRotationsOp
 *
 * \note The C-code was generated by Mathematica, sorry.
 * \todo Clean this up and improve speed
 */
template<typename ConfiguratorType>
class LocalTransitionRotationHessian {
protected:
  typedef typename ConfiguratorType::RealType RealType;

  typedef typename ConfiguratorType::VectorType VectorType;
  typedef typename ConfiguratorType::VecType VecType;
  typedef typename ConfiguratorType::MatType MatType;
  typedef typename ConfiguratorType::RotationType RotationType;
  template<int R>
  using TensorType = Eigen::Tensor<RealType, R>;

public:
  explicit LocalTransitionRotationHessian() = default;

  void apply( const RealType &theta, const RealType &a, const RealType &b, const RealType &c,
              TensorType<4> &Dest ) const {
    Dest.resize( 3, 3, 4, 4 );
    Dest.setZero();

    // From here on: auto-generated code from Mathematica
    const int I0_0 = 1;

    const int I0_1 = 4;

    const int I0_2 = 2;

    const int I0_3 = 3;

    const int I0_4 = -3;

    const int I0_5 = 6;

    const int I0_6 = 8;

    const int I0_7 = -2;

    const int I0_8 = -4;

    const int I0_9 = -6;

    const int I0_10 = -5;

    const int I0_11 = -8;

    const int I0_12 = 5;

    const int I0_13 = 0;

    const RealType R0_12 = -0.25;

    const RealType R0_33 = 0.5;

    const RealType R0_35 = -0.5;

    const RealType R0_41 = 1.5;

    RealType R0_0;
    RealType R0_1;
    RealType R0_2;
    RealType R0_3;
    RealType R0_4;
    RealType R0_5;
    RealType R0_6;
    RealType R0_7;
    RealType R0_8;
    RealType R0_9;
    RealType R0_10;
    RealType R0_11;
    RealType R0_13;
    RealType R0_14;
    RealType R0_15;
    RealType R0_16;
    RealType R0_17;
    RealType R0_18;
    RealType R0_19;
    RealType R0_20;
    RealType R0_21;
    RealType R0_22;
    RealType R0_23;
    RealType R0_24;
    RealType R0_25;
    RealType R0_26;
    RealType R0_27;
    RealType R0_28;
    RealType R0_29;
    RealType R0_30;
    RealType R0_31;
    RealType R0_32;
    RealType R0_34;
    RealType R0_36;
    RealType R0_37;
    RealType R0_38;
    RealType R0_39;
    RealType R0_40;
    RealType R0_42;
    RealType R0_43;
    RealType R0_44;
    RealType R0_45;
    RealType R0_46;
    RealType R0_47;
    RealType R0_48;
    RealType R0_49;
    RealType R0_50;
    RealType R0_51;
    RealType R0_52;
    RealType R0_53;
    RealType R0_54;
    RealType R0_55;
    RealType R0_56;
    RealType R0_57;
    RealType R0_58;
    RealType R0_59;
    RealType R0_60;
    RealType R0_61;
    RealType R0_62;
    RealType R0_63;
    RealType R0_64;
    RealType R0_65;
    RealType R0_66;
    RealType R0_67;
    RealType R0_68;
    RealType R0_69;
    RealType R0_70;
    RealType R0_71;
    RealType R0_72;
    RealType R0_73;
    RealType R0_74;
    RealType R0_75;
    RealType R0_76;
    RealType R0_77;
    RealType R0_78;
    RealType R0_79;
    RealType R0_80;
    RealType R0_81;
    RealType R0_82;
    RealType R0_83;
    RealType R0_84;
    RealType R0_85;
    RealType R0_86;
    RealType R0_87;
    RealType R0_88;
    RealType R0_89;
    RealType R0_90;
    RealType R0_91;
    RealType R0_92;
    RealType R0_93;
    RealType R0_94;
    RealType R0_95;
    RealType R0_96;
    RealType R0_97;
    RealType R0_98;
    RealType R0_99;
    RealType R0_100;
    RealType R0_101;
    RealType R0_102;
    RealType R0_103;
    RealType R0_104;
    RealType R0_105;
    RealType R0_106;
    RealType R0_107;
    RealType R0_108;
    RealType R0_109;
    RealType R0_110;
    RealType R0_111;
    RealType R0_112;
    RealType R0_113;
    RealType R0_114;
    RealType R0_115;
    RealType R0_116;
    RealType R0_117;
    RealType R0_118;
    RealType R0_119;
    RealType R0_120;
    RealType R0_121;
    RealType R0_122;
    RealType R0_123;
    RealType R0_124;
    RealType R0_125;
    RealType R0_126;
    RealType R0_127;
    RealType R0_128;
    RealType R0_129;
    RealType R0_130;
    RealType R0_131;
    RealType R0_132;
    RealType R0_133;
    RealType R0_134;
    RealType R0_135;
    RealType R0_136;
    RealType R0_137;
    RealType R0_138;
    RealType R0_139;
    RealType R0_140;
    RealType R0_141;
    RealType R0_142;
    RealType R0_143;
    RealType R0_144;
    RealType R0_145;
    RealType R0_146;
    RealType R0_147;
    RealType R0_148;
    RealType R0_149;
    RealType R0_150;
    RealType R0_151;
    RealType R0_152;
    RealType R0_153;
    RealType R0_154;
    RealType R0_155;
    RealType R0_156;
    RealType R0_157;
    RealType R0_158;
    RealType R0_159;
    RealType R0_160;
    RealType R0_161;
    RealType R0_162;
    RealType R0_163;
    RealType R0_164;
    RealType R0_165;
    RealType R0_166;
    RealType R0_167;
    RealType R0_168;
    RealType R0_169;
    RealType R0_170;
    RealType R0_171;
    RealType R0_172;
    RealType R0_173;
    RealType R0_174;
    RealType R0_175;
    RealType R0_176;
    RealType R0_177;
    RealType R0_178;
    RealType R0_179;
    RealType R0_180;
    RealType R0_181;
    RealType R0_182;
    RealType R0_183;
    RealType R0_184;
    RealType R0_185;
    RealType R0_186;
    RealType R0_187;
    RealType R0_188;
    RealType R0_189;
    RealType R0_190;
    RealType R0_191;
    RealType R0_192;
    RealType R0_193;
    RealType R0_194;
    RealType R0_195;
    RealType R0_196;
    RealType R0_197;
    RealType R0_198;
    RealType R0_199;
    RealType R0_200;
    RealType R0_201;
    RealType R0_202;
    RealType R0_203;
    RealType R0_204;
    RealType R0_205;
    RealType R0_206;
    RealType R0_207;
    RealType R0_208;
    RealType R0_209;
    RealType R0_210;
    RealType R0_211;
    RealType R0_212;
    RealType R0_213;
    RealType R0_214;
    RealType R0_215;
    RealType R0_216;
    RealType R0_217;
    RealType R0_218;
    RealType R0_219;
    RealType R0_220;
    RealType R0_221;
    RealType R0_222;
    RealType R0_223;
    RealType R0_224;
    RealType R0_225;
    RealType R0_226;
    RealType R0_227;
    RealType R0_228;
    RealType R0_229;
    RealType R0_230;
    RealType R0_231;


    R0_0 = theta;
    R0_1 = a;
    R0_2 = b;
    R0_3 = c;
    R0_4 = R0_1 * R0_1;
    R0_5 = 1 / R0_4;
    R0_4 = R0_2 * R0_2;
    R0_6 = 1 / R0_4;
    R0_4 = R0_1 * R0_1;
    R0_7 = R0_2 * R0_2;
    R0_8 = R0_3 * R0_3;
    R0_9 = -R0_8;
    R0_10 = R0_4 + R0_7 + R0_9;
    R0_11 = R0_10 * R0_10;
    R0_13 = R0_12 * R0_5 * R0_6 * R0_11;
    R0_14 = ( RealType ) I0_0;
    R0_14 = R0_14 + R0_13;
    R0_15 = sqrt( R0_14 );
    R0_16 = cos( R0_0 );
    R0_17 = 1 / R0_1;
    R0_18 = 1 / R0_2;
    R0_19 = sin( R0_0 );
    R0_20 = -R0_7;
    R0_21 = R0_4 + R0_20 + R0_8;

    unsigned int S0 = I0_1;
    RealType S1 = R0_1;
    bool S2 = false;
    if ( S0 < 0 ) {
      S2 = true;
      S0 = -S0;
    }
    R0_22 = 1;
    while ( S0 ) {
      if ( S0 & 1 ) {
        R0_22 = S1 * R0_22;
      }
      S1 = S1 * S1;
      S0 = S0 >> 1;
    }
    if ( S2 ) {
      R0_22 = 1 / R0_22;
    }

    R0_23 = -R0_22;
    R0_24 = R0_7 + R0_9;
    R0_25 = R0_24 * R0_24;
    R0_26 = -R0_25;
    R0_27 = R0_7 + R0_8;
    R0_28 = ( RealType ) I0_2;
    R0_28 = R0_28 * R0_4 * R0_27;
    R0_29 = R0_23 + R0_26 + R0_28;
    R0_30 = 1. / sqrt( R0_29 );
    R0_31 = R0_4 + R0_20 + R0_9;
    R0_32 = 1. / sqrt( R0_14 );
    R0_34 = R0_33 * R0_5 * R0_18 * R0_10 * R0_21 * R0_30 * R0_19;
    R0_36 = R0_35 * R0_5 * R0_18 * R0_10 * R0_21 * R0_30 * R0_16;
    R0_37 = R0_35 * R0_5 * R0_18 * R0_21 * R0_19;
    R0_38 = R0_33 * R0_5 * R0_18 * R0_21 * R0_16;

    S0 = I0_3;
    S1 = R0_1;
    S2 = false;
    if ( S0 < 0 ) {
      S2 = true;
      S0 = -S0;
    }
    R0_39 = 1;
    while ( S0 ) {
      if ( S0 & 1 ) {
        R0_39 = S1 * R0_39;
      }
      S1 = S1 * S1;
      S0 = S0 >> 1;
    }
    if ( S2 ) {
      R0_39 = 1 / R0_39;
    }

    R0_40 = 1 / R0_39;
    R0_39 = pow( R0_29, R0_41 );
    R0_42 = 1 / R0_39;
    R0_39 = ( RealType ) I0_4;
    R0_39 = R0_39 * R0_22 * R0_25;

    S0 = I0_1;
    S1 = R0_24;
    S2 = false;
    if ( S0 < 0 ) {
      S2 = true;
      S0 = -S0;
    }
    R0_43 = 1;
    while ( S0 ) {
      if ( S0 & 1 ) {
        R0_43 = S1 * R0_43;
      }
      S1 = S1 * S1;
      S0 = S0 >> 1;
    }
    if ( S2 ) {
      R0_43 = 1 / R0_43;
    }


    R0_44 = -R0_43;

    S0 = I0_5;
    S1 = R0_1;
    S2 = false;
    if ( S0 < 0 ) {
      S2 = true;
      S0 = -S0;
    }
    R0_45 = 1;
    while ( S0 ) {
      if ( S0 & 1 ) {
        R0_45 = S1 * R0_45;
      }
      S1 = S1 * S1;
      S0 = S0 >> 1;
    }
    if ( S2 ) {
      R0_45 = 1 / R0_45;
    }

    R0_46 = R0_45 * R0_27;
    R0_47 = ( RealType ) I0_3;
    R0_47 = R0_47 * R0_4 * R0_25 * R0_27;
    R0_48 = R0_39 + R0_44 + R0_46 + R0_47;

    S0 = I0_1;
    S1 = R0_2;
    S2 = false;
    if ( S0 < 0 ) {
      S2 = true;
      S0 = -S0;
    }
    R0_49 = 1;
    while ( S0 ) {
      if ( S0 & 1 ) {
        R0_49 = S1 * R0_49;
      }
      S1 = S1 * S1;
      S0 = S0 >> 1;
    }
    if ( S2 ) {
      R0_49 = 1 / R0_49;
    }

    S0 = I0_1;
    S1 = R0_3;
    S2 = false;
    if ( S0 < 0 ) {
      S2 = true;
      S0 = -S0;
    }
    R0_50 = 1;
    while ( S0 ) {
      if ( S0 & 1 ) {
        R0_50 = S1 * R0_50;
      }
      S1 = S1 * S1;
      S0 = S0 >> 1;
    }
    if ( S2 ) {
      R0_50 = 1 / R0_50;
    }


    S0 = I0_6;
    S1 = R0_1;
    S2 = false;
    if ( S0 < 0 ) {
      S2 = true;
      S0 = -S0;
    }
    R0_51 = 1;
    while ( S0 ) {
      if ( S0 & 1 ) {
        R0_51 = S1 * R0_51;
      }
      S1 = S1 * S1;
      S0 = S0 >> 1;
    }
    if ( S2 ) {
      R0_51 = 1 / R0_51;
    }


    S0 = I0_3;
    S1 = R0_24;
    S2 = false;
    if ( S0 < 0 ) {
      S2 = true;
      S0 = -S0;
    }
    R0_52 = 1;
    while ( S0 ) {
      if ( S0 & 1 ) {
        R0_52 = S1 * R0_52;
      }
      S1 = S1 * S1;
      S0 = S0 >> 1;
    }
    if ( S2 ) {
      R0_52 = 1 / R0_52;
    }

    R0_53 = R0_52 * R0_27;
    R0_54 = ( RealType ) I0_2;
    R0_54 = R0_54 * R0_7;
    R0_55 = R0_54 + R0_8;
    R0_56 = ( RealType ) I0_7;
    R0_56 = R0_56 * R0_45 * R0_55;
    R0_57 = R0_7 * R0_8;
    R0_58 = -R0_57;
    R0_57 = R0_49 + R0_58;
    R0_59 = ( RealType ) I0_5;
    R0_59 = R0_59 * R0_22 * R0_57;

    S0 = I0_5;
    S1 = R0_2;
    S2 = false;
    if ( S0 < 0 ) {
      S2 = true;
      S0 = -S0;
    }
    R0_60 = 1;
    while ( S0 ) {
      if ( S0 & 1 ) {
        R0_60 = S1 * R0_60;
      }
      S1 = S1 * S1;
      S0 = S0 >> 1;
    }
    if ( S2 ) {
      R0_60 = 1 / R0_60;
    }

    R0_61 = ( RealType ) I0_8;
    R0_61 = R0_61 * R0_60;
    R0_62 = ( RealType ) I0_9;
    R0_62 = R0_62 * R0_49 * R0_8;
    R0_63 = ( RealType ) I0_6;
    R0_63 = R0_63 * R0_7 * R0_50;

    S0 = I0_5;
    S1 = R0_3;
    S2 = false;
    if ( S0 < 0 ) {
      S2 = true;
      S0 = -S0;
    }
    R0_64 = 1;
    while ( S0 ) {
      if ( S0 & 1 ) {
        R0_64 = S1 * R0_64;
      }
      S1 = S1 * S1;
      S0 = S0 >> 1;
    }
    if ( S2 ) {
      R0_64 = 1 / R0_64;
    }

    R0_65 = ( RealType ) I0_2;
    R0_65 = R0_65 * R0_64;
    R0_66 = R0_61 + R0_62 + R0_63 + R0_65;
    R0_67 = R0_4 * R0_66;
    R0_68 = R0_51 + R0_53 + R0_56 + R0_59 + R0_67;
    R0_69 = R0_4 + R0_7 + R0_8;
    R0_70 = ( RealType ) I0_3;
    R0_70 = R0_70 * R0_22 * R0_24;
    R0_71 = ( RealType ) I0_10;
    R0_71 = R0_71 * R0_49;
    R0_72 = ( RealType ) I0_2;
    R0_72 = R0_72 * R0_7 * R0_8;
    R0_73 = ( RealType ) I0_3;
    R0_73 = R0_73 * R0_50;
    R0_74 = R0_71 + R0_72 + R0_73;
    R0_75 = R0_4 * R0_74;
    R0_76 = R0_45 + R0_70 + R0_52 + R0_75;
    R0_77 = -R0_49;
    R0_78 = ( RealType ) I0_7;
    R0_78 = R0_78 * R0_4 * R0_8;
    R0_79 = R0_22 + R0_77 + R0_78 + R0_50;
    R0_80 = R0_35 * R0_17 * R0_6 * R0_79 * R0_30 * R0_19;
    R0_81 = R0_33 * R0_17 * R0_6 * R0_31 * R0_10 * R0_30 * R0_16;
    R0_82 = R0_33 * R0_17 * R0_6 * R0_31 * R0_19;
    R0_83 = R0_35 * R0_17 * R0_6 * R0_31 * R0_16;
    R0_84 = R0_35 * R0_5 * R0_6 * R0_69;
    R0_85 = R0_35 * R0_5 * R0_6 * R0_42 * R0_68 * R0_16;
    R0_86 = R0_35 * R0_5 * R0_6 * R0_42 * R0_68 * R0_19;
    R0_87 = -R0_51;
    R0_88 = R0_52 * R0_27;
    R0_89 = -R0_88;
    R0_88 = ( RealType ) I0_2;
    R0_88 = R0_88 * R0_45 * R0_55;
    R0_90 = ( RealType ) I0_9;
    R0_90 = R0_90 * R0_22 * R0_57;
    R0_91 = ( RealType ) I0_1;
    R0_91 = R0_91 * R0_60;
    R0_92 = ( RealType ) I0_5;
    R0_92 = R0_92 * R0_49 * R0_8;
    R0_93 = ( RealType ) I0_11;
    R0_93 = R0_93 * R0_7 * R0_50;
    R0_94 = ( RealType ) I0_7;
    R0_94 = R0_94 * R0_64;
    R0_95 = R0_91 + R0_92 + R0_93 + R0_94;
    R0_96 = R0_4 * R0_95;
    R0_97 = R0_87 + R0_89 + R0_88 + R0_90 + R0_96;
    R0_98 = R0_35 * R0_5 * R0_6 * R0_42 * R0_97;
    R0_99 = R0_35 * R0_5 * R0_6 * R0_69 * R0_16;
    R0_100 = R0_35 * R0_5 * R0_6 * R0_69 * R0_19;

    S0 = I0_3;
    S1 = R0_2;
    S2 = false;
    if ( S0 < 0 ) {
      S2 = true;
      S0 = -S0;
    }
    R0_101 = 1;
    while ( S0 ) {
      if ( S0 & 1 ) {
        R0_101 = S1 * R0_101;
      }
      S1 = S1 * S1;
      S0 = S0 >> 1;
    }
    if ( S2 ) {
      R0_101 = 1 / R0_101;
    }

    R0_102 = 1 / R0_101;
    R0_101 = R0_20 + R0_8;

    S0 = I0_3;
    S1 = R0_101;
    S2 = false;
    if ( S0 < 0 ) {
      S2 = true;
      S0 = -S0;
    }
    R0_103 = 1;
    while ( S0 ) {
      if ( S0 & 1 ) {
        R0_103 = S1 * R0_103;
      }
      S1 = S1 * S1;
      S0 = S0 >> 1;
    }
    if ( S2 ) {
      R0_103 = 1 / R0_103;
    }

    R0_104 = R0_8 * R0_103;
    R0_105 = ( RealType ) I0_3;
    R0_105 = R0_105 * R0_7;
    R0_106 = ( RealType ) I0_1;
    R0_106 = R0_106 * R0_8;
    R0_107 = R0_105 + R0_106;
    R0_108 = R0_45 * R0_107;
    R0_109 = -R0_108;
    R0_108 = R0_7 * R0_8;
    R0_110 = ( RealType ) I0_2;
    R0_110 = R0_110 * R0_50;
    R0_111 = R0_49 + R0_108 + R0_110;
    R0_112 = ( RealType ) I0_3;
    R0_112 = R0_112 * R0_22 * R0_111;
    R0_113 = ( RealType ) I0_4;
    R0_113 = R0_113 * R0_7 * R0_50;
    R0_114 = ( RealType ) I0_1;
    R0_114 = R0_114 * R0_64;
    R0_115 = R0_60 + R0_92 + R0_113 + R0_114;
    R0_116 = R0_4 * R0_115;
    R0_117 = -R0_116;
    R0_116 = R0_51 + R0_104 + R0_109 + R0_112 + R0_117;
    R0_118 = R0_4 + R0_9;
    R0_119 = ( RealType ) I0_12;
    R0_119 = R0_119 * R0_7;
    R0_120 = ( RealType ) I0_3;
    R0_120 = R0_120 * R0_8;
    R0_121 = R0_119 + R0_120;
    R0_122 = R0_22 * R0_121;
    R0_123 = -R0_122;
    R0_122 = ( RealType ) I0_3;
    R0_122 = R0_122 * R0_49;
    R0_124 = R0_122 + R0_72 + R0_73;
    R0_125 = R0_4 * R0_124;
    R0_126 = R0_45 + R0_52 + R0_123 + R0_125;
    R0_127 = R0_35 * R0_5 * R0_6 * R0_3 * R0_10 * R0_32 * R0_19;
    R0_128 = R0_33 * R0_5 * R0_6 * R0_3 * R0_10 * R0_32 * R0_16;
    R0_129 = R0_17 * R0_18 * R0_3 * R0_19;
    R0_130 = R0_17 * R0_18 * R0_3 * R0_16;
    R0_131 = -R0_130;
    R0_130 = R0_5 * R0_18 * R0_3;
    R0_132 = R0_5 * R0_18 * R0_3 * R0_42 * R0_76 * R0_16;
    R0_133 = R0_5 * R0_18 * R0_3 * R0_42 * R0_76 * R0_19;
    R0_134 = R0_5 * R0_18 * R0_3 * R0_42 * R0_76;
    R0_135 = -R0_134;
    R0_134 = R0_5 * R0_18 * R0_3 * R0_16;
    R0_136 = R0_5 * R0_18 * R0_3 * R0_19;
    R0_137 = R0_17 * R0_6 * R0_3;
    R0_138 = R0_17 * R0_6 * R0_3 * R0_42 * R0_126 * R0_16;
    R0_139 = R0_17 * R0_6 * R0_3 * R0_42 * R0_126 * R0_19;
    R0_140 = R0_17 * R0_6 * R0_3 * R0_42 * R0_126;
    R0_141 = -R0_140;
    R0_140 = R0_17 * R0_6 * R0_3 * R0_16;
    R0_142 = R0_17 * R0_6 * R0_3 * R0_19;
    R0_143 = R0_7 + R0_120;
    R0_144 = R0_22 * R0_143;
    R0_145 = -R0_144;
    R0_144 = ( RealType ) I0_5;
    R0_144 = R0_144 * R0_7 * R0_8;
    R0_146 = R0_77 + R0_144 + R0_73;
    R0_147 = R0_4 * R0_146;
    R0_148 = R0_45 + R0_52 + R0_145 + R0_147;
    R0_149 = R0_15 * R0_16;
    R0_150 = -R0_149;
    R0_149 = R0_15 * R0_19;
    R0_151 = -R0_149;
    R0_149 = R0_35 * R0_17 * R0_18 * R0_10 * R0_16;
    R0_152 = R0_35 * R0_17 * R0_18 * R0_10 * R0_19;
    R0_153 = -R0_16;
    R0_154 = R0_40 * R0_18 * R0_24;
    R0_155 = R0_40 * R0_18 * R0_42 * R0_48 * R0_16;
    R0_156 = -R0_155;
    R0_155 = R0_40 * R0_18 * R0_42 * R0_48 * R0_19;
    R0_157 = -R0_155;
    R0_155 = ( RealType ) I0_3;
    R0_155 = R0_155 * R0_22 * R0_25;
    R0_158 = R0_45 * R0_27;
    R0_159 = -R0_158;
    R0_158 = ( RealType ) I0_4;
    R0_158 = R0_158 * R0_4 * R0_25 * R0_27;
    R0_155 = R0_155 + R0_43 + R0_159 + R0_158;
    R0_159 = R0_40 * R0_18 * R0_42 * R0_155;
    R0_155 = -R0_159;
    R0_159 = R0_40 * R0_18 * R0_24 * R0_16;
    R0_158 = R0_40 * R0_18 * R0_24 * R0_19;
    R0_160 = R0_17 * R0_102 * R0_118;
    R0_161 = R0_17 * R0_102 * R0_42 * R0_116 * R0_16;
    R0_162 = R0_17 * R0_102 * R0_42 * R0_116 * R0_19;
    R0_163 = R0_17 * R0_102 * R0_42 * R0_116;
    R0_164 = -R0_163;
    R0_163 = R0_17 * R0_102 * R0_118 * R0_16;
    R0_165 = R0_17 * R0_102 * R0_118 * R0_19;
    R0_166 = R0_17 * R0_18;
    R0_167 = -R0_166;
    R0_166 = R0_17 * R0_18 * R0_42 * R0_148 * R0_16;
    R0_168 = -R0_166;
    R0_166 = R0_17 * R0_18 * R0_42 * R0_148 * R0_19;
    R0_169 = -R0_166;
    R0_166 = -R0_45;
    R0_170 = -R0_52;
    R0_171 = R0_22 * R0_143;
    R0_172 = ( RealType ) I0_9;
    R0_172 = R0_172 * R0_7 * R0_8;
    R0_173 = ( RealType ) I0_4;
    R0_173 = R0_173 * R0_50;
    R0_174 = R0_49 + R0_172 + R0_173;
    R0_172 = R0_4 * R0_174;
    R0_166 = R0_166 + R0_170 + R0_171 + R0_172;
    R0_170 = R0_17 * R0_18 * R0_42 * R0_166;
    R0_166 = -R0_170;
    R0_170 = R0_17 * R0_18 * R0_16;
    R0_171 = -R0_170;
    R0_170 = R0_17 * R0_18 * R0_19;
    R0_172 = -R0_170;
    R0_170 = ( RealType ) I0_13;
    R0_174 = ( RealType ) I0_13;
    R0_173 = ( RealType ) I0_13;
    R0_175 = ( RealType ) I0_13;
    R0_176 = ( RealType ) I0_13;
    R0_177 = ( RealType ) I0_13;
    R0_178 = ( RealType ) I0_13;
    R0_179 = ( RealType ) I0_13;
    R0_180 = ( RealType ) I0_13;
    R0_181 = ( RealType ) I0_13;
    R0_182 = ( RealType ) I0_13;
    R0_183 = ( RealType ) I0_13;
    R0_184 = ( RealType ) I0_13;
    R0_185 = ( RealType ) I0_13;
    R0_186 = ( RealType ) I0_13;
    R0_187 = ( RealType ) I0_13;
    R0_188 = ( RealType ) I0_13;
    R0_189 = ( RealType ) I0_13;
    R0_190 = ( RealType ) I0_13;
    R0_191 = ( RealType ) I0_13;
    R0_192 = ( RealType ) I0_13;
    R0_193 = ( RealType ) I0_13;
    R0_194 = ( RealType ) I0_13;
    R0_195 = ( RealType ) I0_13;
    R0_196 = ( RealType ) I0_13;
    R0_197 = ( RealType ) I0_13;
    R0_198 = ( RealType ) I0_13;
    R0_199 = ( RealType ) I0_13;
    R0_200 = ( RealType ) I0_13;
    R0_201 = ( RealType ) I0_13;
    R0_202 = ( RealType ) I0_13;
    R0_203 = ( RealType ) I0_13;
    R0_204 = ( RealType ) I0_13;
    R0_205 = ( RealType ) I0_13;
    R0_206 = ( RealType ) I0_13;
    R0_207 = ( RealType ) I0_13;
    R0_208 = ( RealType ) I0_13;
    R0_209 = ( RealType ) I0_13;
    R0_210 = ( RealType ) I0_13;
    R0_211 = ( RealType ) I0_13;
    R0_212 = ( RealType ) I0_13;
    R0_213 = ( RealType ) I0_13;
    R0_214 = ( RealType ) I0_13;
    R0_215 = ( RealType ) I0_13;
    R0_216 = ( RealType ) I0_13;
    R0_217 = ( RealType ) I0_13;
    R0_218 = ( RealType ) I0_13;
    R0_219 = ( RealType ) I0_13;
    R0_220 = ( RealType ) I0_13;
    R0_221 = ( RealType ) I0_13;
    R0_222 = ( RealType ) I0_13;
    R0_223 = ( RealType ) I0_13;
    R0_224 = ( RealType ) I0_13;
    R0_225 = ( RealType ) I0_13;
    R0_226 = ( RealType ) I0_13;
    R0_227 = ( RealType ) I0_13;
    R0_228 = ( RealType ) I0_13;
    R0_229 = ( RealType ) I0_13;
    R0_230 = ( RealType ) I0_13;
    R0_231 = ( RealType ) I0_13;

    double *P0 = Dest.data();
    P0[0] = R0_170;
    P0[1] = R0_150;
    P0[2] = R0_151;
    P0[3] = R0_174;
    P0[4] = R0_149;
    P0[5] = R0_152;
    P0[6] = R0_173;
    P0[7] = R0_19;
    P0[8] = R0_153;
    P0[9] = R0_175;
    P0[10] = R0_34;
    P0[11] = R0_36;
    P0[12] = R0_176;
    P0[13] = R0_37;
    P0[14] = R0_38;
    P0[15] = R0_177;
    P0[16] = R0_178;
    P0[17] = R0_179;
    P0[18] = R0_180;
    P0[19] = R0_80;
    P0[20] = R0_81;
    P0[21] = R0_181;
    P0[22] = R0_82;
    P0[23] = R0_83;
    P0[24] = R0_182;
    P0[25] = R0_183;
    P0[26] = R0_184;
    P0[27] = R0_185;
    P0[28] = R0_127;
    P0[29] = R0_128;
    P0[30] = R0_186;
    P0[31] = R0_129;
    P0[32] = R0_131;
    P0[33] = R0_187;
    P0[34] = R0_188;
    P0[35] = R0_189;
    P0[36] = R0_190;
    P0[37] = R0_34;
    P0[38] = R0_36;
    P0[39] = R0_191;
    P0[40] = R0_37;
    P0[41] = R0_38;
    P0[42] = R0_192;
    P0[43] = R0_193;
    P0[44] = R0_194;
    P0[45] = R0_154;
    P0[46] = R0_156;
    P0[47] = R0_157;
    P0[48] = R0_155;
    P0[49] = R0_159;
    P0[50] = R0_158;
    P0[51] = R0_195;
    P0[52] = R0_196;
    P0[53] = R0_197;
    P0[54] = R0_84;
    P0[55] = R0_85;
    P0[56] = R0_86;
    P0[57] = R0_98;
    P0[58] = R0_99;
    P0[59] = R0_100;
    P0[60] = R0_198;
    P0[61] = R0_199;
    P0[62] = R0_200;
    P0[63] = R0_130;
    P0[64] = R0_132;
    P0[65] = R0_133;
    P0[66] = R0_135;
    P0[67] = R0_134;
    P0[68] = R0_136;
    P0[69] = R0_201;
    P0[70] = R0_202;
    P0[71] = R0_203;
    P0[72] = R0_204;
    P0[73] = R0_80;
    P0[74] = R0_81;
    P0[75] = R0_205;
    P0[76] = R0_82;
    P0[77] = R0_83;
    P0[78] = R0_206;
    P0[79] = R0_207;
    P0[80] = R0_208;
    P0[81] = R0_84;
    P0[82] = R0_85;
    P0[83] = R0_86;
    P0[84] = R0_98;
    P0[85] = R0_99;
    P0[86] = R0_100;
    P0[87] = R0_209;
    P0[88] = R0_210;
    P0[89] = R0_211;
    P0[90] = R0_160;
    P0[91] = R0_161;
    P0[92] = R0_162;
    P0[93] = R0_164;
    P0[94] = R0_163;
    P0[95] = R0_165;
    P0[96] = R0_212;
    P0[97] = R0_213;
    P0[98] = R0_214;
    P0[99] = R0_137;
    P0[100] = R0_138;
    P0[101] = R0_139;
    P0[102] = R0_141;
    P0[103] = R0_140;
    P0[104] = R0_142;
    P0[105] = R0_215;
    P0[106] = R0_216;
    P0[107] = R0_217;
    P0[108] = R0_218;
    P0[109] = R0_127;
    P0[110] = R0_128;
    P0[111] = R0_219;
    P0[112] = R0_129;
    P0[113] = R0_131;
    P0[114] = R0_220;
    P0[115] = R0_221;
    P0[116] = R0_222;
    P0[117] = R0_130;
    P0[118] = R0_132;
    P0[119] = R0_133;
    P0[120] = R0_135;
    P0[121] = R0_134;
    P0[122] = R0_136;
    P0[123] = R0_223;
    P0[124] = R0_224;
    P0[125] = R0_225;
    P0[126] = R0_137;
    P0[127] = R0_138;
    P0[128] = R0_139;
    P0[129] = R0_141;
    P0[130] = R0_140;
    P0[131] = R0_142;
    P0[132] = R0_226;
    P0[133] = R0_227;
    P0[134] = R0_228;
    P0[135] = R0_167;
    P0[136] = R0_168;
    P0[137] = R0_169;
    P0[138] = R0_166;
    P0[139] = R0_171;
    P0[140] = R0_172;
    P0[141] = R0_229;
    P0[142] = R0_230;
    P0[143] = R0_231;

  }

  void apply( const RealType &theta, const RealType &a, const RealType &b, const RealType &c,
              std::array<std::array<RotationType, 4>, 4> &Dest ) const {
    TensorType<4> T;
    apply( theta, a, b, c, T );

    for ( int i : { 0, 1, 2, 3 } )
      for ( int j : { 0, 1, 2, 3 } )
        for ( int k : { 0, 1, 2 } )
          for ( int l : { 0, 1, 2 } )
            Dest[i][j]( k, l ) = T( k, l, i, j );

  }

  TensorType<4> operator()( const RealType &theta, const RealType &a, const RealType &b, const RealType &c ) {
    TensorType<4> Dest;
    apply( theta, a, b, c, Dest );
    return Dest;
  }

};

#endif //NRIC_TRANSITIONROTATIONS_H
